<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ray casting</title>
</head>

<body>
  <!-- old trick to make any element focusable: tabindex="1" -->
  <canvas id="canvas" tabindex="1" width="600px" height="400px" style="background-color: black; "></canvas>
  <div class="slidecontainer">
    <p>FOV:</p>
    <input id="slider" type="range" min="0" max="360" value="30">
</body>

</html>
<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const lightRayCnt = 90;
  const FOVelement = document.getElementById("slider");
  const shapes = [
    [{ x: 0, y: 0 }, { x: 600, y: 0 }, { x: 600, y: 400 }, { x: 0, y: 400 }], // border
    [{ x: 200, y: 50 }, { x: 150, y: 140 }, { x: 160, y: 60 }],
    [{ x: 500, y: 150 }, { x: 450, y: 130 }, { x: 460, y: 100 }],
    [{ x: 400, y: 350 }, { x: 250, y: 330 }, { x: 260, y: 300 }]
  ]
  const step = 3; // for moving the light
  let FOV = FOVelement.value;
  let center = { x: ctx.canvas.width / 2, y: ctx.canvas.height / 2 }

  // handles collision for rays and lines/walls
  function getIntersection(r, l) {
    // r:  ray of [{x: r_x, y: r_y}, {x: r_x1, y: r_y1}]
    // l: line of [{x: l_x, y: l_y}, [y: l_x1, y: l_x1}]
    //            initial     terminal

    // find directional vectors
    const r_v = { x: r[1].x - r[0].x, y: r[1].y - r[0].y };
    const l_v = { x: l[1].x - l[0].x, y: l[1].y - l[0].y };

    // check if they are parallel
    const r_m = Math.sqrt(r_v.x * r_v.x + r_v.y * r_v.y);
    const l_m = Math.sqrt(l_v.x * l_v.x + l_v.y * l_v.y);
    if (r_v.x / r_m == l_v.x / l_m && r_v.y / r_m == l_v.y / l_m) {
      return null
    }

    // solve for scalar t1, t2 in r = r0 + tv
    // r_x1 = r_x + t1.r_v_x
    // r_y1 = r_y + t1.r_v_y
    // l_x1 = l_x + t2.l_v_x
    // l_y1 = l_y + t2.l_v_y

    // if the ray and line intersect, the terminal
    // point for r and l is the same

    // solve for T2
    const T2 = (r_v.x * (l[0].y - r[0].y) + r_v.y * (r[0].x - l[0].x))
      / (l_v.x * r_v.y - l_v.y * r_v.x)

    // solve for T1
    const T1 = (l[0].x + l_v.x * T2 - r[0].x) / r_v.x

    // make sure that the point is on the line segment
    if (T1 < 0) {
      return null;
    }
    if (T2 < 0 || T2 > 1) {
      return null
    };

    // plug back in to get intersection point
    return { x: r[0].x + T1 * r_v.x, y: r[0].y + T1 * r_v.y, scalar: T1 }
  }

  // create a new point by rotating the original
  // point {@x, @y} clockwise by @angle to @length
  // function genPoints(x, y, angle, length) {
  //   angle = angle * Math.PI / 180; // degree to radians
  //   return { x: (length * Math.cos(angle) + x).toFixed(2), y: (length * Math.sin(angle) + y).toFixed(2) }
  // }

  // create a new point by rotating the original
  // point {@x, @y} by @angle to central point {@cx, @cy}
  function genPoints(cx, cy, x, y, angle) {
    const rad = angle * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    const nx = (cos * (x - cx)) + (sin * (y - cy)) + cx;
    const ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
    return { x: Math.floor(nx), y: Math.floor(ny) };
  }


  function draw() {
    // clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = 'white';

    // draw walls
    for (var i = 0; i < shapes.length; i++) { //for shape in array
      ctx.beginPath();
      ctx.moveTo(shapes[i][0].x, shapes[i][0].y);
      for (var j = 1; j < shapes[i].length; j++) { //for vertex in shape
        ctx.lineTo(shapes[i][j].x, shapes[i][j].y); //x, y
      }
      ctx.closePath();
      ctx.stroke();
    }

    // find collision for rays and walls
    for (let i = 0; i < lightRayCnt; i++) {
      // ray = [{ x: Mouse.x, y: Mouse.y }, genPoints(Mouse.x, Mouse.y, i * 360 / lightRayCnt, 10)];

      ray = [
        {
          x: center.x,
          y: center.y
        },
        genPoints(
          center.x,
          center.y,
          Mouse.x,
          Mouse.y,
          (i * FOV / lightRayCnt) - FOV / 2
        )
      ];

      // find closest intersection
      let closestIntersect = null;
      let intersect = null;
      for (let i = 0; i < shapes.length; i++) { // for each shape
        for (let j = 0; j < shapes[i].length; j++) { // for each wall in shape
          intersect = getIntersection(ray, [shapes[i][j], shapes[i][(j + 1) % shapes[i].length]]);
          if (intersect) {
            if (!closestIntersect || intersect.scalar < closestIntersect.scalar) {
              closestIntersect = intersect;
            }
          }
        }
      }

      // draw truncated ray from mouse to nearest wall
      if (closestIntersect != null) {
        ctx.beginPath();
        ctx.moveTo(center.x, center.y);
        ctx.lineTo(closestIntersect.x, closestIntersect.y);
        ctx.stroke();
      }
    }
  }

  // draw
  // only redraw at new input
  window.requestAnimationFrame = window.requestAnimationFrame
    || window.webkitRequestAnimationFrame
    || window.mozRequestAnimationFrame
    || window.msRequestAnimationFrame;
  var updateCanvas = true;
  function drawLoop() {
    requestAnimationFrame(drawLoop);
    if (updateCanvas) {
      draw();
      updateCanvas = false;
    }
  }
  window.onload = function () {
    drawLoop();
  };

  // MOUSE	
  var Mouse = {
    x: canvas.width / 2,
    y: canvas.height / 2
  };
  canvas.onmousemove = function (event) {
    Mouse.x = event.clientX;
    Mouse.y = event.clientY;
    updateCanvas = true;
  };
  canvas.onkeydown = function (event) {
    console.log(event.code)
    switch (event.code) {
      case "ArrowUp":
        center.y -= step;
        updateCanvas = true;
        break;
      case "ArrowDown":
        center.y += step;
        updateCanvas = true;
        break;
      case "ArrowLeft":
        center.x -= step;
        updateCanvas = true;
        break;
      case "ArrowRight":
        center.x += step;
        updateCanvas = true;
        break;
      default:
        //ignore
    }
  }
  FOVelement.oninput = function (event) {
    FOV = event.target.value;
    updateCanvas = true;
  }
</script>